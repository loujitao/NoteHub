&emsp;<a href="#0">计算机网络</a>  
&emsp;&emsp;<a href="#1">TCP/IP五层模型（重）</a>  
&emsp;&emsp;<a href="#2">应用层常见的协议</a>  
&emsp;&emsp;<a href="#3">TCP 与 UDP</a>  
&emsp;&emsp;&emsp;<a href="#4">TCP、UDP的区别（重）</a>  
&emsp;&emsp;&emsp;<a href="#5">运行于TCP、UDP上的协议</a>  
&emsp;&emsp;&emsp;<a href="#6">TCP的三次握手、四次挥手（重）</a>  
&emsp;&emsp;&emsp;&emsp;<a href="#7">三次握手</a>  
&emsp;&emsp;&emsp;&emsp;<a href="#8">四次挥手</a>  
&emsp;&emsp;&emsp;<a href="#9">TCP传输可靠性保障</a>  
&emsp;&emsp;&emsp;&emsp;<a href="#10">保证传输的可靠性</a>  
&emsp;&emsp;&emsp;&emsp;<a href="#11">实现流量控制</a>  
&emsp;&emsp;&emsp;&emsp;<a href="#12">拥塞控制的实现</a>  
&emsp;&emsp;&emsp;&emsp;<a href="#13">ARQ协议</a>  
&emsp;&emsp;<a href="#14">HTTP</a>  
&emsp;&emsp;&emsp;<a href="#15">HTTP协议的特点</a>  
&emsp;&emsp;&emsp;<a href="#16">浏览器中输入URL返回页面过程（重）</a>  
&emsp;&emsp;&emsp;<a href="#17">HTTP状态码</a>  
&emsp;&emsp;&emsp;<a href="#18">HTTP和HTTPS的区别（重）</a>  
&emsp;&emsp;&emsp;<a href="#19">HTTP1.0和HTTP1.1的区别</a>  
&emsp;&emsp;&emsp;<a href="#20">HTTP1.1和HTTP2.0的区别</a>  
&emsp;&emsp;&emsp;<a href="#21">HTTP报文格式</a>  
&emsp;&emsp;&emsp;<a href="#22">GET、POST的区别（重）</a>  
&emsp;&emsp;&emsp;<a href="#23">什么是数字证书（重）</a>  
&emsp;&emsp;&emsp;<a href="#24">DNS的解析过程</a>  
&emsp;&emsp;&emsp;<a href="#25">什么是cookie和session（重）</a>  
&emsp;&emsp;&emsp;<a href="#26">Cookie和Session的区别</a>  
&emsp;&emsp;&emsp;<a href="#27">对称加密和非对称加密</a>  
&emsp;&emsp;<a href="#28">ARP协议</a>  
&emsp;&emsp;&emsp;<a href="#29">MAC地址</a>  
&emsp;&emsp;&emsp;<a href="#30">同一局域网内的 MAC 寻址</a>  
&emsp;<a href="#31">参考资料</a>  
## <a name="0">计算机网络




### <a name="1">TCP/IP五层模型（重）


![](https://yingziimage.oss-cn-beijing.aliyuncs.com/img/202211022030199.png)

TCP/IP五层模型：应用层、传输层、网络层、数据链路层、物理层

- 应用层：为程序提供交互服务。在互联网中应用层协议有很多，如域名系统DNS、HTTP协议、SMTP协议
- 传输层：负责向两台主机进程之间的通信提供数据传输服务。协议主要有传输控制协议TCP，用户数据协议UDP
- 网络层：选择合适的路由和交换结点，确保数据及时传送，包括IP协议
- 数据链路层：在两个相邻节点之间传送数据时，将网络层交下来的IP数据包组装成帧，在两个相邻节点间的链路上传送帧
- 物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备差异



### <a name="2">应用层常见的协议


```
HTTP(超文本传输协议)
	- 主要是为Web浏览器与Web服务器之间的通信而设计

SMTP(Simple Mail Transfer Protocol,简单邮件传输协议)
	- 电子邮箱的发送过程（我邮箱"1@qq.com",向目标邮箱"2@qq.com"发生邮件）
		- 通过SMTP协议，将我写好的邮件交给163邮箱服务器(邮局)
		- 163邮箱服务器发现我发送的邮箱是qq邮箱，然后使用SMTP协议将我的邮件转发给qq邮箱服务器
		- qq邮箱服务器接收邮件后通知邮箱"2@qq.com"用户来收邮件，然后用户就通过POP3/IMAP协议将邮件取出
	- 判断邮箱真正存在?
		1.查找邮箱域名对应的SMTP服务器地址
		2.尝试与服务器建立连接
		3.连接成功后尝试向需要验证的邮箱发送邮件
		4.根据返回结构判定邮箱地址的真实性
		
POP3/IMAP(两者都是负责邮件接收的协议)
	
FTP(文件传输协议)
	- 主要提供文件传输服务，基于TCP实现可靠的传输，传输过程可屏蔽操作系统和文件存储方式
	- 基于客户-服务器模型而设计，在客户端、服务器之间建立两个连接
		- 控制连接：用于传送控制信息（命令和响应）
		- 数据连接：用于数据传送

Telnet(远程登陆协议)
	- 通过一个终端登录到其他服务器，建立在可靠的传输协议TCP之上
	- 缺点：所有数据(包括用户名、密码)均以明文形式发送，现如今正在被SSH所替代

SSH(安全的网络传输协议)
	- 建立在可靠的传输协议TCP之上。
	- 可防止信息泄露问题，专门用于远程登录会话和其他网络服务提供安全的协议
```



### <a name="3">TCP 与 UDP


```
TCP：用于对传输准确性要求特别高的场景。如文件传输、发送和接收邮件、远程登录等
UDP：一般用于即时通信。如语音、视频、直播等
```

#### <a name="4">TCP、UDP的区别（重）


| TCP                        | UDP                                |
| -------------------------- | ---------------------------------- |
| 面向连接                   | 无连接                             |
| 提供可靠服务               | 不保证可靠交互                     |
| 有状态                     | 无状态                             |
| 面向字节流                 | 面向报文                           |
| 传输效率较慢               | 传输效率较快                       |
| 有拥塞控制                 | 没有拥塞控制                       |
| 每一条TCP连接只能是<stron> | 支持一对一、一对多、多对一、多对多 |
| 首部开销20字节             | 首部开销8字节                      |

#### <a name="5">运行于TCP、UDP上的协议


```
运行于TCP之上的协议
	- HTTP、HTTPS、FTP、SMTP、POP3/IMAP、Telnet、SSH

运行于UDP之上的协议
	- DHCP：动态主机配置协议，动态配置IP地址
	- DNS：域名系统（DNS，Domain Name System）将人类可读的域名（如www.baidu.com）转化为机器可读的IP地址（如220.181.38.148），可将其理解为专为互联网设计的电话簿。实际上DNS同时支持UDP、TCP
```



#### <a name="6">TCP的三次握手、四次挥手（重）


##### <a name="7">三次握手


假设发送端为客户端，接收端为服务端。开始客户端、服务端的状态都是CLOSED

![](https://yingziimage.oss-cn-beijing.aliyuncs.com/img/202211022107799.png)

```
第一次握手（无任何状态）：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段包含标志位SYN=1，序列号seq=x。第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN

第二次握手（保证：客户端的发送能力、服务器的接收能力没问题）：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，标志位SYN=1，序列号seq=y，ACK=1，确认号ack=x+1。第二次握手后服务端的状态为SYN-RCVD（SYN=1表示要和客户端建立一个连接，ACK=1表示确认序号有效）

第三次握手（保证：客户端的接收能力、服务器的发送能力没问题）：客户端收到服务端发来的报文后，会再向服务端发送报文。ACK=1，序列号seq=x+1，确认号ack=y+1。客户、服务端状态变为ESTABLISTED。此时连接建立完成

A <--> B
第一个包，即A发给B的SYN 中途被丢，没有到达B
	- A会周期性超时重传，直到收到B的确认
第二个包，即B发给A的SYN +ACK 中途被丢，没有到达A
	- B会周期性超时重传，直到收到A的确认
第三个包，即A发给B的ACK 中途被丢，没有到达B
	- A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态
	a. 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认
	b. 假定此时收到A的数据发送，B收到A的Data + ACK,自然切换到established状态，并接受A的Data
	c. 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据
```

##### <a name="8">四次挥手


<img src="https://yingziimage.oss-cn-beijing.aliyuncs.com/img/202211022115921.png" style="zoom: 33%;" />

```
1、A的应用进程先向B发出连接释放报文段（FIN=1,seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1状态。

2、B收到连接释放报文段后发送确认报文段（ACK=1,ack=u+1,seq=v），B进入CLOSE-WAIT状态，此时的TCP处于半关闭状态

3、A收到B的确认后，进入FIN-WAIT-2状态，等待B发出的连接释放报文段

4、B发送完数据，就发出连接释放报文段（FIN=1,seq=w,ACK=1,ack=u+1），B进入LAST-ACK状态

5、A收到B的连接释放报文段后，发出确认报文段（ACK=1,seq=u+1,ack=w+1），A进入TIME-WAIT状态。此时TCP未释放掉，需要经过时间等待计时器设置的2MSL（最大报文段生存时间）后，A进入ClOSE状态。B在收到A发出的确认报文段后关闭连接，若没收到则B会重传连接释放报文段

四次挥手为什么要等待2MSL?
	- 保证A发送的最后一个ACK报文段能够达到B。这个ACK报文段可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，A可以在这个2MSL时间内收到这个重传的连接释放报文段，接着A重传一次确认，并重新启动2MSL计时器，最后A和B都进入CLOSED状态。若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段立即进入CLOSED，则无法收到B重传的连接释放报文段，那么A不会再发一次确认报文段，B就无法正常进入CLOSED状态
	
为什么是四次挥手?
	- TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接
	- 举个栗子，A和B打电话
		第一次挥手： A 说“我没啥要说的了”
		第二次挥手 ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话
		第三次挥手 ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”
		第四次挥手 ：A 回答“知道了”，这样通话才算结束
```

#### <a name="9">TCP传输可靠性保障


##### <a name="10">保证传输的可靠性


```
基于数据块传输
	- 应用数据被分割成TCP认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段

对失序数据包重新排序以及去重
	- TCP为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号进行排序，并且去掉重复序列号的数据就可以实现数据包去重
	
校验和
	- TCP将保持它首部和数据的检验和。这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段
	
超时重传
	- 当发送方发送数据之后，它会启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传
	
流量控制
	- TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议（TCP利用滑动窗口实现流量控制）
	
拥塞控制
	- 当网络拥塞时，减少数据发送
```

##### <a name="11">实现流量控制


```
TCP利用滑动窗口实现流量控制。流量控制时为了控制发送方的发送速率，保证接收方来得及接收
	- 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则接收方不能发送数据
	
为什么需要流量控制?
	- 双方在通信时，发送方的速率与接收方的速率不一定相等，若发送方的发送速率太快会导致接收方处理不过来。接收方只能把处理不过来的数据存放在接收缓冲区（Receiving Buffers）里，失序的数据包也会被存放在缓存区里。若缓存区慢了发送方还在发数据的话，接收方会把收到的数据包丢掉，出现丢包问题同时又浪费着网络资源。因此，我们需要控制发送方的发送速率
	
发送端不等于客户端；接收端不等于服务端
	- TCP为全双工（Full-Duplex,FDX）通信，双方可以进行双向通信，客户端和服务端既是发送又是服务端
	- 两端各有一个发送缓冲区与接收缓冲区，两端都各种维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同
	
TCP发送窗口可以划分成四部分
	1. 已经发送并确认的TCP段
	2. 已经发送但没有确认的TCP段
	3. 未发送但是接收方准备接收的TCP段
	4. 未发送且接收方未准备接收的TCP段
	
TCP接收窗口可以划分成三个部分
	1. 已经接收并确认的TCP段
	2. 等待接收且允许发送方发送TCP段
	3. 不可接收且不允许发送方发送TCP段
接收窗口的大小是根据接收端处理数据的速度动态调整的。若接收端读取数据快，接收窗口可能会扩大
```

##### <a name="12">拥塞控制的实现


![](https://yingziimage.oss-cn-beijing.aliyuncs.com/img/202302111534708.png)

```
在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞
	- 拥塞控制就是为了防止过多的数据注入到网络中，这样就可用使网络中的路由器或链路不致过载
	- 拥塞控制是一个全局性的过程，涉及到所有主机、所有路由器，以及与降低网络传输性能有关的所有因素
	
为了进行拥塞窗口，TCP发送方要维持一个拥塞窗口(cwnd)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个

TCP的拥塞控制采用了四种算法：慢开始、拥塞避免、快重传、快恢复
	- 慢开始：当主机开始发送数据时，若立即把大量数据字节注入到网络，可能会引起网络阻塞。由小到大逐渐增大拥塞窗口的数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍
	- 拥塞避免：让拥塞窗口cwnd缓慢增大，每经过一个传播轮次，cwnd+1
	- 快重传和快恢复：FRRfast retransmit and recovery)能快速恢复丢失的数据包。
		- 没有FRR，若数据包丢失了，TCP将会使用定时器来要求传输暂停。在暂停这段时间内，没有新的或复制的数据包被发送。
		- 有了FRR，若接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。若发送机接收到三个重复确认，它会确认数据段丢失并立即重传这些丢失的数据段。
			- 单独的数据包丢失，FRR能最有效的工作
			- 多个数据包在很短的时间内丢失，则不能很有效的工作
```

##### <a name="13">ARQ协议


```
自动重传请求（Automatic Repeat-reQuest,ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时两个机制，在不可靠服务的基础上实现可靠的信息传输。若发送方在发送一段时间内没有收到确认信息（ACK），它通常会重新发送，直到收到确认或重试超过一定的次数

ARQ包括停止等待ARQ、连续ARQ协议

停止ARQ协议：实现可靠传输。它的基本原理是每发完一个分组就停止发送，等待对方确认（回复ACK），若过了一段时间还是没收到ACK确认，就说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；若接收方收到重复分组，就丢弃该分组，但同时还有发送确认
	- 无差错情况
		- 发送方发送分组，接收方再规定时间内收到，并且回复确认，发送方再次发送
	- 出现差错情况(超时重传)
		- 超过一段时间没有收到确认，就重传前面发送过的分组。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据再分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ
	- 确认丢失和确认迟到
		- 确认丢失：确认消息再传输过程中丢失。A发送M1给B，B收到并发送确认，却在传输过程中丢失。A并不知道，在超时计时后，A重传M1消息，B再次收到该消息后采取以下两点措施
			1. 丢弃这个重复的M1消息，不向上层交付
			2. 向A发送确认消息
		- 确认迟到：确认消息在传输过程中迟到。A发送M1给B，B收到并发送确认，在超时时间内A没收到确认，A重传M1，B收到并继续发送确认（B收到两份M1）。此时A收到B第二次发送的确认。过了一会，A收到B收到的第一次发送的确认（A也收到了两份确认），处理如下
			1. A收到重复确认后直接丢弃
			2. B收到重复M1后，也直接丢弃重复的M1
			
连续ARQ协议：提供信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到
	- 优点：信道利用率高，容易实现，即使确认丢失，也不必重传
	- 缺点：不能向发送方反映出接收方已经正确收到的所有分组信息
		- 比如：发送方发送了5条信息，中间第三条丢失，接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，只好把后三个全部重传一次，这也叫Go-Back-N(回退N)，表示需要退回来重传已经发送过的N个消息
```



### <a name="14">HTTP


#### <a name="15">HTTP协议的特点


```
- HTTP允许传输任意类型的数据，传输的类型由Content-Type加以标记
- 无状态。对于客户端每次发送的请求，服务器都认为是一个新的请求，上一次会话和下一次会话之间没有联系
- 支持客户端/服务器模式
```



#### <a name="16">浏览器中输入URL返回页面过程（重）


```
1、解析域名，找到主机IP
2、浏览器利用IP直接与网站主机通信，三次握手，建立TCP连接。浏览器会以一个随机端口向服务端的web程序80端口发起TCP连接
3、建立TCP连接后，浏览器向主机发起一个HTTP请求
4、服务器响应请求，返回响应数据
5、浏览器解析响应内容，进行渲染，呈现给用户
```

#### <a name="17">HTTP状态码


| 状态码 | 解释                                   |
| ------ | -------------------------------------- |
| 1xx    | 服务器收到请求，需要请求者继续执行操作 |
| 2xx    | 请求正常处理完毕                       |
| 3xx    | 重定向，需要进一步操作已完成请求       |
| 4xx    | 客户端错误，服务器无法处理请求         |
| 5xx    | 服务器处理请求出错                     |

#### <a name="18">HTTP和HTTPS的区别（重）


```
HTTP是超文本传输协议，信息是明文传输；HTTPS则是具有安全性的ssl加密传输协议
HTTP端口是80，HTTPS端口是443
HTTP运行在TCP协议上；HTTPS运行在SSL协议，SSL运行在TCP之上
HTTPS协议需要到CA机构申请证书，一般需要一定的费用
```



#### <a name="19">HTTP1.0和HTTP1.1的区别


```
连接方式：HTTP1.0为短连接、HTTP1.1支持长连接
	- 短连接：浏览器与服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接
	- 长连接：复用TCP连接，多个HTTP请求可以复用同一个TCP连接，节省TCP连接建立、断开的消耗

状态响应码：HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种,如
	- 100(Continue)：在请求大资源前的预热请求
	- 206(Partial Content)：范围请求的标识码
	- 409(Conflict)：请求与当前资源的规定冲突
	
缓存处理：HTTP1.0中主要使用了header里的if-Modified-Since,Expirese作为缓存判断标注；HTTP1.1则引入更多的缓存策略如if-Unmodified-Since等

带宽优化及网络连接的使用：HTTP1.0存在浪费带宽的现象，例如客户端只需要某对象的一部分，而服务器却将整个对象送过来，且不支持断点续传功能；HTTP1.1则在请求头引入了range头域，它允许只请求资源的某部分

Host头处理：HTTP/1.1在请求头中加入了Host字段
```



#### <a name="20">HTTP1.1和HTTP2.0的区别


```
新的二进制格式：HTTP1.1基于文本格式传输数据；HTTP2.0采用二进制格式传输数据，解析更高效

多路复用：在一个连接里，允许同时发送多个请求或响应，并且这些请求或响应能够并行的传输而不被阻塞，避免HTTP1.1出现"队头堵塞"问题

头部压缩：HTTP1.1的header带有大量信息，而且每次都要重复发送；HTTP2.0把header从数据中分离，并封装成头帧和数据帧，使用特定算法压缩头帧。并且HTTP2.0在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。比如请求a发送了所有的头信息字段，请求b则只需要发送差异数据，这样就减少冗余数据，降低开销

服务端推送：HTTP2.0允许服务器向客户端推送资源，无需客户端发送请求到服务器获取
```



#### <a name="21">HTTP报文格式


HTTP请求四个组成部分：请求行、请求头、空行、请求体

- 请求行：包括请求方法，访问的资源URL，使用的HTTP版本。GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE
- 请求头：格式为“属性名:属性值”，服务端根据请求头获取客户端的信息，主要有cookie、host、connection、accept-language、accept-encoding、user-agent
- 请求体：用户的请求数据，如用户名、密码等

请求报文实例

```http
POST /xxx HTTP/1.1 请求行
Accept:image/gif.image/jpeg, 请求头部
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate

username=dabin 请求体
```

HTTP响应也由四部分组成：状态行、响应头、空行、响应体

- 状态行：协议版本，状态码及状态描述
- 响应头：响应头字段主要有connection、content-type、conten-encoding、content-length、set-cookie、Last-Modified、Cache-Control、Expires
- 响应体：服务器返回给客户端的内容

响应报文示例

```http
HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112

<html>
    <body>响应体</body>
</html>
```

#### <a name="22">GET、POST的区别（重）


```
GET请求参数通过URL传递；POST参数放在请求体中
GET请求只能进行url编码，而POST支持多种编码方式
GET请求会被浏览器主动缓存；POST不会，除非手动设置
GET请求参数会被完整保留在浏览器历史记录里；POST中的参数不会被保留
GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式请求，浏览器会把请求头和请求体一并发出去，而对于POST，先发送请求头，服务器响应100 continue，浏览器再发送请求体
```



#### <a name="23">什么是数字证书（重）


服务端可以向证书颁发机构(CA)申请证书，以避免中间人攻击（防止证书被篡改），证书包含三部分：证书内容、证书签名算法、签名

服务端把证书传输给浏览器，浏览器从证书里取公钥。证书可以证明该公钥对应本网站

```
数字签名的制作过程
	1、CA使用证书签名算法对证书内容进行hash运算
	2、对hash后的值用CA的私钥加密，得到数字签名

浏览器验证过程
	1、获取证书，得到证书内容、证书签名算法、数字签名
	2、用CA机构的公钥对数字签名解密（由于是浏览器信任的机构，所以浏览器会保存它的公钥）
	3、用证书里的签名算法对证书内容进行hash运算
	4、比较解密后的数字签名和对证书内容做hash运算后得到的哈希值，相等则表明证书可信
```



#### <a name="24">DNS的解析过程


```
1、浏览器搜索自己的DNS缓存
2、若没有，则搜索系统中的DNS缓存和hosts文件
3、若没有，操作系统将域名发送至本地域名服务器，本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则依次向根域名服务器、顶级域名服务器、权限域名服务器发起查询请求，最终返回IP地址给本地域名服务器
4、本地域名服务器将得到的IP地址返回给操作系统，同时自己也将IP地址缓存起来
5、操作系统将IP地址返回给浏览器，同时缓存IP地址
6、浏览器得到域名对应的IP地址
```

#### <a name="25">什么是cookie和session（重）


由于HTTP协议是无状态的协议，需要用某种机制来识别具体的用户身份，用来跟踪用户的整个会话。常用的会话跟踪协议是cookie、session

```
cookie就是由服务器发送给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。说得更具体一点，当用户使用浏览器访问一个支持cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在客户端回传相应的超文本的同时也会发回这些个人信息，这些信息存储于HTTP响应头中。当客户浏览器接收来自服务器的响应之后，浏览器将信息存放在一个统一的位置。自此，客户端再向服务器发送请求的时候，都会把相应的cookie存放与HTTP请求头，再次发回至服务器。服务器在接收到客户端浏览器的请求之后，就能够通过分析存放于请求头的cookie得到客户端持有的信息，从而动态生成与该客户端相对应的内容，网站的登录界面中“请记住我”这样的选项，就是通过cookie实现的
```

cookie工作流程

- 1、servlet创建cookie，保存少量数据，发送给浏览器
- 2、浏览器获得服务器发送的cookie数据，将自动保存到浏览器端
- 3、下次访问时，浏览器将自动携带cookie数据发送给服务器

```
session原理：首先浏览器请求服务器访问web站点时，服务器首先会检查这个客户端请求是否已经包含了一个session标识，称为SESSIONED，如果已经包含了一个sessionid则说明以前为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用，如果客户端请求不包含sessinon id，则服务器为此客户端创建一个session，并且生成一个与此session相关联的独一无二的sessionid存放到cookie中，这个sessionid将在本次响应中返回到客户端保存，这样在交互的过程中，浏览器每次请求时，都会带着这个sessionid，服务器根据这个sessionid就可以得到对应的session。以此来达到共享数据的目的，session不会随着浏览器的关闭而死亡，而是等待超时时间
```

#### <a name="26">Cookie和Session的区别


```
作用范围不同：Cookie保存在客户端；Session保存在服务器端

隐私策略不同：Cookie存储在客户端，容易被窃取；Seesion存储在服务器端，安全性相对要高

有效期不同：Cookie可设置为长时间保持，比如默认登录功能；Session一般失效时间较短，客户端关闭或者Session超时都会失效

存储大小不同：单个Cookie保存的数据不超过4K；Session存储没有上限，但出于对服务器性能考虑，不用存放过多数据，且需要设置删除机制
```

#### <a name="27">对称加密和非对称加密


- 对称加密：通信双方使用相同的密钥进行加密，特点是加密速度快，但缺点是密钥泄露会导致密文数据被破解。常见的有：AES、DES算法
- 非对称加密：需要生成两个密钥，公钥和私钥。公钥是公开的，任何人可以获得，私钥是私人保管。公钥负责加密，私钥负责解密；或者私钥负责加密，公钥负责解密。这种加密算法安全性更高，计算量相对要大，加密和解密都很慢，常见的有：RSA、DSA



### <a name="28">ARP协议




#### <a name="29">MAC地址


```
MAC全称媒体访问控制地址（Media Access Control Address）：如果说互联网中每一个资源都由IP地址唯一标识，那么一切网络设备都由MAC地址唯一标识
	- 做个比较：MAC地址是身份证号，IP地址是邮政地址。MAC地址具有可携带性、永久性
```





#### <a name="30">同一局域网内的 MAC 寻址


```
每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。

当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、MAC地址、以及目的主机的IP地址。

网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。

源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。
如果源主机一直没有收到ARP响应数据包，表示ARP查询失败
```





## <a name="31">参考资料


[(74条消息) 计算机网络面试突击_小朱小朱绝不服输的博客-CSDN博客](https://blog.csdn.net/weixin_44052055/article/details/122944016)

[计算机网络常见面试题总结 | JavaGuide(Java面试+学习指南)](https://javaguide.cn/cs-basics/network/other-network-questions.html)
